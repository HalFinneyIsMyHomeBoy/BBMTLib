package certs

import (
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"math/big"
	"net"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/nbd-wtf/go-nostr"
	"github.com/nostr-dns/nodns-cli/internal/auth"
	"github.com/spf13/viper"
)

// NostrCertificate represents a certificate as stored in Nostr events
type NostrCertificate struct {
	TLD       string
	PEM       string
	Subject   string
	Issuer    string
	NotBefore time.Time
	NotAfter  time.Time
	Generated bool // true if generated by this tool
}

// FetchCurrentCertificates retrieves current certificates for the logged-in user from Nostr
func FetchCurrentCertificates() ([]NostrCertificate, error) {
	user, err := auth.GetCurrentUser()
	if err != nil {
		return nil, fmt.Errorf("failed to get current user: %w", err)
	}

	// Get relays from config
	relayURLs := strings.Split(viper.GetString("relays"), ",")
	if len(relayURLs) == 0 {
		return nil, fmt.Errorf("no relays configured")
	}

	ctx := context.Background()
	var certificates []NostrCertificate

	// Query for all certificate events (kind 30003)
	filter := nostr.Filter{
		Kinds:   []int{30003}, // Certificate events
		Authors: []string{user.PublicKey},
	}

	for _, relayURL := range relayURLs {
		relayURL = strings.TrimSpace(relayURL)
		if relayURL == "" {
			continue
		}

		relay, err := nostr.RelayConnect(ctx, relayURL)
		if err != nil {
			fmt.Printf("Failed to connect to relay %s: %v\n", relayURL, err)
			continue
		}

		// Subscribe to events
		sub, err := relay.Subscribe(ctx, []nostr.Filter{filter})
		if err != nil {
			fmt.Printf("Failed to subscribe to relay %s: %v\n", relayURL, err)
			relay.Close()
			continue
		}

		// Collect events with timeout
		timeout := time.After(5 * time.Second)
		eventMap := make(map[string]*nostr.Event) // TLD -> latest event

	eventLoop:
		for {
			select {
			case event := <-sub.Events:
				// Extract TLD from d tag
				var tld string
				for _, tag := range event.Tags {
					if len(tag) >= 2 && tag[0] == "d" {
						tld = tag[1]
						break
					}
				}
				if tld != "" {
					// Keep only the latest event per TLD
					if existing, exists := eventMap[tld]; !exists || event.CreatedAt > existing.CreatedAt {
						eventMap[tld] = event
					}
				}
			case <-sub.EndOfStoredEvents:
				break eventLoop
			case <-timeout:
				break eventLoop
			}
		}

		sub.Unsub()
		relay.Close()

		// Parse certificates from collected events
		for _, event := range eventMap {
			cert := parseCertificateFromEvent(event)
			if cert != nil {
				certificates = append(certificates, *cert)
			}
		}

		if len(certificates) > 0 {
			return certificates, nil
		}
	}

	return certificates, nil
}

// PublishCertificate publishes a single certificate to Nostr
func PublishCertificate(tld, pemData string, generated bool) error {
	user, err := auth.GetCurrentUser()
	if err != nil {
		return fmt.Errorf("failed to get current user: %w", err)
	}

	// Parse certificate to get metadata
	block, _ := pem.Decode([]byte(pemData))
	if block == nil || block.Type != "CERTIFICATE" {
		return fmt.Errorf("invalid PEM certificate data")
	}

	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return fmt.Errorf("failed to parse certificate: %w", err)
	}

	// Create Nostr event for this certificate
	event := &nostr.Event{
		Kind:      30003, // Certificate event (addressable)
		CreatedAt: nostr.Timestamp(time.Now().Unix()),
		Content:   pemData,
		Tags: []nostr.Tag{
			{"d", tld}, // Addressable identifier (TLD)
			{"expiry", fmt.Sprintf("%d", cert.NotAfter.Unix())},
		},
	}

	// Sign the event
	if err := event.Sign(user.PrivateKey); err != nil {
		return fmt.Errorf("failed to sign event: %w", err)
	}

	// Get relays from config
	relayURLs := strings.Split(viper.GetString("relays"), ",")
	if len(relayURLs) == 0 {
		return fmt.Errorf("no relays configured")
	}

	// Publish to relays
	ctx := context.Background()
	published := 0

	for _, relayURL := range relayURLs {
		relayURL = strings.TrimSpace(relayURL)
		if relayURL == "" {
			continue
		}

		relay, err := nostr.RelayConnect(ctx, relayURL)
		if err != nil {
			fmt.Printf("Failed to connect to relay %s: %v\n", relayURL, err)
			continue
		}

		if err := relay.Publish(ctx, *event); err != nil {
			fmt.Printf("Failed to publish certificate to relay %s: %v\n", relayURL, err)
		} else {
			fmt.Printf("Published certificate for .%s to relay: %s\n", tld, relayURL)
			published++
		}

		relay.Close()
	}

	if published == 0 {
		return fmt.Errorf("failed to publish certificate to any relay")
	}

	fmt.Printf("Successfully published certificate for .%s to %d relays\n", tld, published)
	return nil
}

// GenerateAndPublishCertificate generates a certificate, saves it locally, and immediately publishes to Nostr
func GenerateAndPublishCertificate(tld, outputDir string) error {
	user, err := auth.GetCurrentUser()
	if err != nil {
		return fmt.Errorf("failed to get current user: %w", err)
	}

	fmt.Printf("Generating certificate for .%s\n", tld)

	// Generate private key
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return fmt.Errorf("failed to generate private key: %w", err)
	}

	// Generate a cryptographically secure random serial number
	serialNumber, err := generateRandomSerial()
	if err != nil {
		return fmt.Errorf("failed to generate certificate serial number: %w", err)
	}

	// Create certificate template with domain-specific values to ensure uniqueness
	// Use a deterministic but unique timestamp base to prevent time-collision issues
	baseTime := time.Now().Truncate(time.Hour) // Truncate to hour to allow some variance

	// Pre-calculate domain for use in certificate fields
	domainName := fmt.Sprintf("%s.%s", user.NPub, tld)

	template := x509.Certificate{
		SerialNumber: serialNumber, // Already made unique with crypto random
		Subject: pkix.Name{
			Organization:       []string{fmt.Sprintf("NoDNS - %s", user.NPub)},
			OrganizationalUnit: []string{tld}, // Make TLD-specific
			Country:            []string{"Internet"},
			Province:           []string{"Nostr"},
			Locality:           []string{"Decentralized"},
			CommonName:         domainName, // Domain-specific CN
		},
		NotBefore:   baseTime,
		NotAfter:    baseTime.Add(365 * 24 * time.Hour), // 1 year from base time
		KeyUsage:    x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		IPAddresses: []net.IP{},
	}

	// Add DNS names
	domain := fmt.Sprintf("%s.%s", user.NPub, tld)
	template.DNSNames = append(template.DNSNames, domain)
	template.DNSNames = append(template.DNSNames, fmt.Sprintf("*.%s", domain))

	// Create certificate
	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		return fmt.Errorf("failed to create certificate: %w", err)
	}

	// Encode certificate to PEM
	certPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certDER,
	})

	// Encode private key to PEM
	privateKeyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
	})

	// Determine output directory (current directory if not specified)
	if outputDir == "" {
		outputDir = "."
	}

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Save certificate to file
	certPath := filepath.Join(outputDir, fmt.Sprintf("%s.%s.crt", user.NPub, tld))
	if err := os.WriteFile(certPath, certPEM, 0644); err != nil {
		return fmt.Errorf("failed to save certificate to %s: %w", certPath, err)
	}
	fmt.Printf("Certificate saved to: %s\n", certPath)

	// Save private key to file
	keyPath := filepath.Join(outputDir, fmt.Sprintf("%s.%s.key", user.NPub, tld))
	if err := os.WriteFile(keyPath, privateKeyPEM, 0600); err != nil {
		return fmt.Errorf("failed to save private key to %s: %w", keyPath, err)
	}
	fmt.Printf("Private key saved to: %s\n", keyPath)

	// Immediately publish to Nostr
	if err := PublishCertificate(tld, string(certPEM), true); err != nil {
		return fmt.Errorf("failed to publish certificate: %w", err)
	}

	fmt.Printf("Generated certificate for .%s\n", tld)
	return nil
}

// ListCurrentCertificates shows all current certificates from Nostr
func ListCurrentCertificates() error {
	user, err := auth.GetCurrentUser()
	if err != nil {
		return fmt.Errorf("failed to get current user: %w", err)
	}

	fmt.Printf("Fetching SSL certificates for %s from Nostr...\n", user.NPub)

	certificates, err := FetchCurrentCertificates()
	if err != nil {
		return err
	}

	if len(certificates) == 0 {
		fmt.Printf("No SSL certificates found on Nostr for %s\n", user.NPub)
		fmt.Println("Use 'nodns certs generate' to create certificates.")
		return nil
	}

	fmt.Printf("\nSSL Certificates for %s:\n", user.NPub)
	fmt.Println("========================================")

	for i, cert := range certificates {
		status := "üìÑ"
		if cert.Generated {
			status = "üîß"
		}
		status += " üì°" // Always published since we fetch from Nostr

		fmt.Printf("%d. %s .%s\n", i+1, status, cert.TLD)
		fmt.Printf("   Domain: %s.%s\n", user.NPub, cert.TLD)
		fmt.Printf("   Subject: %s\n", cert.Subject)
		fmt.Printf("   Valid: %s - %s\n",
			cert.NotBefore.Format("2006-01-02"),
			cert.NotAfter.Format("2006-01-02"))

		if cert.NotAfter.Before(time.Now()) {
			fmt.Printf("   ‚ö†Ô∏è  EXPIRED\n")
		} else if cert.NotAfter.Before(time.Now().AddDate(0, 0, 30)) {
			fmt.Printf("   ‚ö†Ô∏è  Expires soon\n")
		}

		fmt.Println()
	}

	fmt.Printf("\nTotal: %d certificates\n", len(certificates))
	fmt.Println("Legend: üìÑ = Imported, üîß = Generated, üì° = Published to Nostr")
	return nil
}

// RemoveCertificate removes a certificate from Nostr (publishes empty event)
func RemoveCertificate(tld string) error {
	user, err := auth.GetCurrentUser()
	if err != nil {
		return fmt.Errorf("failed to get current user: %w", err)
	}

	// Create deletion event (empty content with same d tag)
	event := &nostr.Event{
		Kind:      30003, // Certificate event
		CreatedAt: nostr.Timestamp(time.Now().Unix()),
		Content:   "", // Empty content indicates deletion
		Tags: []nostr.Tag{
			{"d", tld}, // Same addressable identifier
		},
	}

	// Sign the event
	if err := event.Sign(user.PrivateKey); err != nil {
		return fmt.Errorf("failed to sign deletion event: %w", err)
	}

	// Get relays from config
	relayURLs := strings.Split(viper.GetString("relays"), ",")
	if len(relayURLs) == 0 {
		return fmt.Errorf("no relays configured")
	}

	// Publish deletion to relays
	ctx := context.Background()
	published := 0

	for _, relayURL := range relayURLs {
		relayURL = strings.TrimSpace(relayURL)
		if relayURL == "" {
			continue
		}

		relay, err := nostr.RelayConnect(ctx, relayURL)
		if err != nil {
			fmt.Printf("Failed to connect to relay %s: %v\n", relayURL, err)
			continue
		}

		if err := relay.Publish(ctx, *event); err != nil {
			fmt.Printf("Failed to publish deletion to relay %s: %v\n", relayURL, err)
		} else {
			fmt.Printf("Published certificate deletion for .%s to relay: %s\n", tld, relayURL)
			published++
		}

		relay.Close()
	}

	if published == 0 {
		return fmt.Errorf("failed to publish deletion to any relay")
	}

	fmt.Printf("Successfully removed certificate for .%s from %d relays\n", tld, published)
	return nil
}

// parseCertificateFromEvent extracts certificate information from a Nostr event
func parseCertificateFromEvent(event *nostr.Event) *NostrCertificate {
	// Skip events with empty content (deleted certificates)
	if event.Content == "" {
		return nil
	}

	// Extract TLD from d tag
	var tld string
	for _, tag := range event.Tags {
		if len(tag) >= 2 && tag[0] == "d" {
			tld = tag[1]
			break
		}
	}

	if tld == "" {
		return nil
	}

	// Parse certificate to get metadata
	block, _ := pem.Decode([]byte(event.Content))
	if block == nil || block.Type != "CERTIFICATE" {
		return nil
	}

	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return nil
	}

	return &NostrCertificate{
		TLD:       tld,
		PEM:       event.Content,
		Subject:   cert.Subject.String(),
		Issuer:    cert.Issuer.String(),
		NotBefore: cert.NotBefore,
		NotAfter:  cert.NotAfter,
		Generated: true, // We assume it was generated (we can't differentiate in Nostr events)
	}
}

// generateRandomSerial creates a cryptographically secure random serial number for certificates
func generateRandomSerial() (*big.Int, error) {
	// Generate a 128-bit (16-byte) random number for the serial
	// This provides 2^128 possible serial numbers, making collisions extremely unlikely
	serialBytes := make([]byte, 16)
	if _, err := rand.Read(serialBytes); err != nil {
		return nil, fmt.Errorf("failed to generate random bytes: %w", err)
	}

	// Ensure the serial number is positive by clearing the most significant bit
	serialBytes[0] &= 0x7F

	// Convert bytes to big.Int
	serial := new(big.Int).SetBytes(serialBytes)

	// Ensure serial is never zero (required by X.509 standard)
	if serial.Cmp(big.NewInt(0)) == 0 {
		serial = big.NewInt(1)
	}

	return serial, nil
}
